---
layout: post
title: "EDR Network Connection Telemetry & Malware Beaconing - A Threat Hunt"
date: 2025-04-11
author: Cory Keller
---

## How it started

I have been actively expanding my Cybersecurity skill set and mastering new topics in attempts to understand vague CVE write ups so I can better secure my employers or clients network. The process has been both intellectually rewarding and deeply motivating, satisfying a constant drive to learn and grow. With my master's program completed, I’ve found myself independently pursuing advanced topics to continue challenging myself and sharpening my skills.

What I have landed on for the past couple of months is I thought about ways machine learning can be applied to Cybersecurity (without much research into what has been done to not spoil it for myself and ruin a journey) after reading an article on machine learning applications in identifying avian egg viability. [Bok-Bok-Bok][egg-viability] I had my own or so I thought epiphany, can I use machine learning to identify potentially malicious commands being executed on hosts? I went all in on this topic. I over engineered a bunch of code and utilized libraries I really should not have to come to an answer that yes I can identify but because of using models such as LSTM I was coming to wrong answers, slow training of the model, highly inaccurate predictions of new data. 

Then as if someone was hearing my bangs on my desk and heavy sighs, LimaCharlie had a defender friday where Joshua Neil was the guest speaker and he discussed things he has done with Cybersecurity and applied machine learning at a place near and dear to my heart. I reached out eagerly on linked in and asked to picked his brain and with zero hesitation he helped me and guided me on a reset of this endeavour. I switched up models, fixed pre processing of my dataset and trained with appropriate models. So a thank you to Joshua Neil for the encouragement and aiding me on this endeavour. Ultimately, I realized I needed guided education on machine learning as it was not my world (yet). I landed on SANS SEC595 as part of my annual education purchase. That class quickly became my favorite of any I have taken with them. 

In the SANs course there is a lab for detection of C2 Beacon activity using Numpy [fourier transformations][fourier]. Don't worry this blog post is not me translating math to you, lets be honest, that level of math was not for me and you do not need me explaining it. Anyways, the lab really made me re-evaluate how I can build a better suite of applications/tools for my own business and how can I apply it to what I currently use. In my previous blog post I applied hunting activities to EventID 3 with Velociraptor and now I come right back to EventID 3, along with LimaCharlie EDR's NETWORK_CONNECTION logs as well to identify these beacon activities.

## The Data

I really do not want to spend much time generating data when all of it can be simulated for our purposes as we know what that data will be. The [Sysmon Documentation][sysmon-docs] really explains what is in each event pretty well. So all that is needed is to build a script that gives me exactly what I want from the data. A destination IP and a timestamp are what is needed. The benefits of using the logs we are using we can have a host name and a executable that is causing the network connection.

Below is a Sysmon Event ID log and a Lima Charlie EDR "NETWORK_CONNECTION" Event.

### Event ID vs NETWORK_CONNECTION Log

```xml
Network connection detected
RuleName: RDP
UtcTime: 2017-04-28 22:12:22.557
ProcessGuid: {a23eae89-bd28-5903-0000-00102f345d00}
ProcessId: 13220
Image: C:\Program Files (x86)\Google\Chrome\Application\chrome.exe
User: LAB\rsmith
Protocol: tcp
Initiated: true
SourceIsIpv6: false
SourceIp: 192.168.1.250
SourceHostname: rfsH.lab.local
SourcePort: 3328
SourcePortName:
DestinationIsIpv6: false
DestinationIp: 104.130.229.150
DestinationHostname:
DestinationPort: 3389
DestinationPortName: ms-wbt-server
```

EVENT ID 3 from [Event ID 3][event-id-3]

```json
event":{
"COMMAND_LINE":""C:\Program Files (x86)\Microsoft\EdgeWebView\Application\134.0.3124.93\msedgewebview2.exe" --type=utility --utility-sub-type=network.mojom.NetworkService --lang=en-US --service-sandbox-type=none --no…"
"FILE_IS_SIGNED":1
"FILE_PATH":"C:\Program Files (x86)\Microsoft\EdgeWebView\Application\134.0.3124.93\msedgewebview2.exe"
"HASH":"e715c1557c931c332b51bf20b89ee1b8736ad7406a3c55531e2b800ff70a18b7"
"NETWORK_ACTIVITY":[
{
"DESTINATION":{
"IP_ADDRESS":"23.198.7.171"
"PORT":443
}
"IS_OUTGOING":1
"PROTOCOL":"tcp4"
"SOURCE":{
"IP_ADDRESS":"10.11.1.141"
"PORT":59177
}
"TIMESTAMP":1743972709336
}
{
"DESTINATION":{
"IP_ADDRESS":"2600:1406:5e00:49::17ce:e5a5"
"PORT":443
}
"IS_OUTGOING":1
"PROTOCOL":"tcp6"
"SOURCE":{
"IP_ADDRESS":"2603:3000:1f:c500:1538:f632:ef00:467f"
"PORT":59178
}
"TIMESTAMP":1743972709337
}
{
"DESTINATION":{
"IP_ADDRESS":"2620:1ec:21::16"
"PORT":443
}
"IS_OUTGOING":1
"PROTOCOL":"tcp6"
"SOURCE":{
"IP_ADDRESS":"2603:3000:1f:c500:1538:f632:ef00:467f"
"PORT":59179
}
"TIMESTAMP":1743972709379
}
]
```

LimaCharlie EDR [NETWORK_CONNECTION][lc-netconns] Event

As seen you gain much more useful insights into the connection over Sysmon EventID 3 with an EDR network connection log and can ask more questions of that data. Likely for your needs, you can triage the whole alert that is created from having access to this data and move right into the infected host(s) to start analysis. This logic can be done from an API call to pull those logs for organization X and that API response can be moved into a dataframe and preprocessed before being used with FFT transformations.

Armed with a csv of fake data to test this method with data in logs I utilize. Im ready to go. The python script generated random timestamps for the current day when the script is ran and random IP v4 addresses are placed in the fields, last the evil beaconing is created at a set interval with one destination IP address. During testing I realized I had forgotten to give the logs a "SourceHostName" field and the "Image" field (whole reason of going this route...). So I generated a couple small functions to add that information to the data frame as seen in the screenshot below.

![Adding Additional Simulated Data]({{ "/assets/images/Beacon_Screenshots/simulated_evtx_3.png" | relative_url }})

For a quick and dirty explanation, Fourier transforms are measuring something over time to determine frequency of the event. We don't need it to be in Hertz/hits per second. Frequency is over the time of the log. I gave this data a big chance to show how this can work in an environment but yet a realistic possibility of how long an attacker can be inside the environment before detection. I would hope that its sooner than the timeline's in the CSV (over 2 days) but there are case studies showing much longer timelines to detection. That being said with how often the beacon is occurring and set to every 5 seconds the attacker would deserve to be caught with this scenario. In order to measure the frequency of the IP addresses I converted them to integers. Then used numpy's FFT module to transform the data. See screenshot below.

![DataFrame View and FFT Transform]({{ "/assets/images/Beacon_Screenshots/DataFrame1.png" | relative_url }}))

Converting all connections to integers and plotting the FFT transform we do not have CLEAR indications of what beaconing activity is happening. Scaling data only made it more difficult to see any variation in connection attempts. That has to do with the number of connections being measured vs the figure size. When I change figure size to 5000, 5 and zoom in the beaconing become that much more obvious. That is ok the method does not rely on a human's ability to read a graph. 

### All IPs Plotted

![All IPs Plotted]({{ "/assets/images/Beacon_Screenshots/FFT-ALL_IPs-Plotted.png" | relative_url }}))

### All IPs Plotted Zoomed

![Rescaled Plot]({{ "/assets/images/Beacon_Screenshots/FFT-ALL_IPs-Plotted-5000.png" | relative_url }})

## Successful Hunt!

Now for the part where we look for each IP address that can be a beacon. To automate something like this and find the beaconing. You measure your mean/average of the FFT variable set and the standard deviation in the FFT data. If you find some connection that has a FFT value larger than the mean and standard deviation as found in this threat hunting notebook put out by [Target][target-beacon]. See screenshot below for expected data output. 

![Malicious IP Found]({{ "/assets/images/Beacon_Screenshots/malicious_ip_found.png" | relative_url }})

If you want to confirm visually you can plot only the return IP addresses from your logic for each IP returned. Expected output below. 

![45.55.67.75 Beaconing Plotted]({{ "/assets/images/Beacon_Screenshots/Beacons.png" | relative_url }})

The value of that output should be immediately apparent, we can effectively output anything from the dataframe as part of that generated log and have an alert that is confident and what is doing it. No digging into the logs to do temporal analysis of what executables did what at what time then trying to tie that activity to the executables in question. We went from 1000s or millions of possibilities in your organization down to 1. Making the time from detection to remediation drastically lower.

[sysmon-docs]: https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon
[event-id-3]: https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?source=Sysmon&eventID=3
[swift-config]:https://github.com/SwiftOnSecurity/sysmon-config
[egg-viability]: https://www.sciencedirect.com/science/article/pii/S2772375525000905
[fourier]: https://lpsa.swarthmore.edu/Fourier/Xforms/FXformIntro.html
[lc-netconns]: https://docs.limacharlie.io/v2/docs/reference-edr-events#networkconnections
[target-beacon]: https://github.com/target/Threat-Hunting/blob/master/Beacon%20Hunting/find_beacons_by_fourier.ipynb
